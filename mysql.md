### 转换表引擎的几种方法
* ALTER TABLE
ALTER TABLE mytable ENGINE = InnoDB;
需要执行很长时间，可能会消耗系统所有I/O能力，同时原表会加读锁。
* 导出与导入
使用mysqldump工具将数据导出到文件，需改表名及存储引擎选项后导入。需注意其中自动生成的DROP TABLE语句。
* 创建与查询（CREATE AND SELECT）
综合了第一种方法的高效和第二种方法的安全。创建一个新存储引擎的表，使用INSERT...SELECT语法导入数据。若数据量很大考虑分批处理。

# MYSQL基准测试
基准测试可以完成的工作：
* 验证基于系统的一些假设，确认这些假设是否符合实际情况。
* 重现系统中的某些异常行为，以解决这些异常。
* 测试系统当前的运行情况。
* 模拟比当前系统更高的负载。
* 规划未来的业务增长。
* 测试应用适应可变环境的能力。
* 测试不同的硬件、软件和操作系统配置。
* 证明新采购的设备是否配置正确。
## 基准测试工具
### 集成式测试工具
ab:
http_load:
JMeter:
### 单组件式测试工具
mysqlslap:
MySQL Benchmark Suite(sql-bench)
Super Smack:
Database Test Suite:
Percona's TPCC-MySQL Tool:
sysbench
# 服务器性能剖析
慢查询日志是MySQL中一种轻量而且功能全面的性能剖析工具。
## 诊断间歇性问题

# Schema与数据类型优化
* 更小的通常更好
* 简单就好，如使用内建类型而不是字符串来存储日期和时间，使用整型存储IP地址
* 尽量避免NULL
> 通常把可谓NULL的列改为NOT NULL带来的性能提升比较小，InnoDB与MyISAM不同，对稀疏数据有很好的空间效率。

### 整数类型
TINYINT,SMALLINT,MEDIUMINT,INT,BIGINT分别使用8，16，24，32，64位存储空间。可选UNSIGNED属性，性能相同，整数上限提高一倍。
### 实数类型
FLOAT和DOUBLE支持使用标准的浮点运算进行近似计算。
>精度定义是非标准的，建议只制定数据类型，不指定精度。
DECIMAL用于存储精确的小数。
>因为需要额外的空间和计算开销，应尽量只在对小数进行精确计算时才使用DECIMAL。在数据量比较大的时候，可以考虑使用BIGINT代替DECIMAL，可以同时避免浮点存储计算不精确和DECIMAL精确计算代价高的问题。
### 字符串类型
VARCHAR需要使用1或2个额外字节记录字符串的长度：如果列的最大长度小于等于255字节则使用1个字节，否则使用2个字节。
下面情况使用VARCHAR是合适的：字符串列的最大长度比平均长度大很多；列的更新很少，所以碎片不是问题；使用了像UTF-8这样复杂的字符集，每个字符都是用不同的字节数进行存储。
InnoDB可以把过长的VARCHAR存储为BLOB。
填充和截取空格的行为在MySQL服务器层处理，所以在不同存储引擎都是一样的。
### 日期和时间类型
通常尽量使用TIMESTAMP，比DATETIME空间效率更高。整数保存时间通常不方便处理。
### 位数据类型
谨慎使用BIT类型，对于大部分应用，最好避免使用。

一个粗略的经验法则，如果希望查询执行的快速并且并发性好，单个查询最好在12个表以内做关联。

改变列默认值有两种方法
MODIFY COLUMN 拷贝了整张表，速度慢。
ALTER COLUMN 直接修改存储列默认值的.frm文件，速度快，不涉及表数据。

# 创建高性能索引
## 基础
索引可以包含一个或多个列的值。如果索引包含多个列，那么列的顺序也十分重要。因为MySQL只能高效的使用索引的最左前缀列。
### 索引类型
* B-Tree索引
* 哈希索引，基于哈希表实现。MySQL中只有Memory引擎显式支持哈希索引。
* 空间数据索引（R-Tree）:MysQL中支持不完善，一般不使用。PostgreSQL对此支持较好。
* 全文索引
## 索引的优点
* 大大减少了服务器需要扫描的数据量。
* 帮助服务器避免排序和临时表。
* 将随机I/O变为顺序I/O。

对于TB级别的数据，定位单条记录的意义不大，所以经常使用块级别元数据技术来替代索引。

## 高性能索引策略
* 独立的列：索引列不能是表达式的一部分，也不能是函数的参数。
* 前缀索引：对于BLOB、TEXT或很长的VARCHAR列，必须使用前缀索引，MySQL不允许索引这些列的完整长度。
前缀索引能使索引更小、更快，但MySQL无法使用前缀索引做ORDER BY和GROUP BY，也无法使用前缀索引做覆盖扫描。
> 有时候后缀索引（suffix index）也有用途，MySQL原生不支持反向索引，可以将字符串反转后存储，通过触发器维护。
* 多列索引：
如果EXPLAIN中看到有索引合并，应检查查询和表的结构是否为最优。可以通过参数optimizer_switch关闭索引合并功能。也可以使用IGNORE INDEX提示让优化器忽略某些索引。
* 选择合适的索引列顺序
> 适用于B-Tree索引
* 聚簇索引
InnoDB支持聚簇索引
聚簇索引可能对性能有帮助，也可能导致严重的性能问题。

> 顺序主键什么时候会造成更坏的结果？
* 覆盖索引

## 索引案例学习
设计在线约会网站，用户信息表的查询。
其中sex、country列选择性不高，但很多查询都会用到，建议在创建不同组合索引的时候将（sex、country）列作为前缀。
即使查询没有使用sex列也可以通过以下诀窍绕过：
如果某个查询不限制性别，在查询条件中新增 and sex in('m', 'f')，使MySQL选择该索引。

将age列放在索引的最后面，因为查询只能使用索引的最左前缀，直到遇到第一个范围条件列。age列多半是范围查询。

### 避免多个范围条件
### 优化排序
延迟关联，通过使用覆盖索引查询返回需要的主键，再根据主键关联原表获得需要的行。可以减少MySQL扫描那些需要丢弃的行数。

## 维护索引和表

